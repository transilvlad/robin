package com.mimecast.robin.bots;

import com.mimecast.robin.mime.EmailParser;
import com.mimecast.robin.mime.parts.MimePart;
import com.mimecast.robin.mime.parts.TextMimePart;
import com.mimecast.robin.mx.MXResolver;
import com.mimecast.robin.mx.StrictMx;
import com.mimecast.robin.mx.assets.DnsRecord;
import com.mimecast.robin.mx.client.XBillDnsRecordClient;
import com.mimecast.robin.mx.dane.DaneChecker;
import com.mimecast.robin.mx.dane.DaneRecord;
import com.mimecast.robin.scanners.rbl.RblChecker;
import com.mimecast.robin.scanners.rbl.RblResult;
import com.mimecast.robin.smtp.MessageEnvelope;
import com.mimecast.robin.smtp.connection.Connection;
import com.mimecast.robin.smtp.session.Session;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.xbill.DNS.Address;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Email infrastructure analysis bot that performs comprehensive email security checks.
 * <p>This bot analyzes:
 * <ul>
 *   <li>DNSBL/RBL - Sender IP reputation</li>
 *   <li>rDNS - Reverse DNS lookup</li>
 *   <li>FCrDNS - Forward Confirmed Reverse DNS</li>
 *   <li>SPF - Sender Policy Framework (from Rspamd)</li>
 *   <li>DKIM - DomainKeys Identified Mail (from Rspamd and email headers)</li>
 *   <li>DMARC - Domain-based Message Authentication (from Rspamd)</li>
 *   <li>MX Records - Mail server records</li>
 *   <li>MTA-STS - Mail Transfer Agent Strict Transport Security</li>
 *   <li>DANE - DNS-Based Authentication of Named Entities</li>
 *   <li>Virus Scan - ClamAV results</li>
 *   <li>Spam Score - Rspamd analysis</li>
 * </ul>
 *
 * <p>The bot generates a comprehensive text report with all findings and queues it for delivery.
 */
public class EmailAnalysisBot implements BotProcessor {
    private static final Logger log = LogManager.getLogger(EmailAnalysisBot.class);

    // Default RBL providers to check.
    private static final List<String> DEFAULT_RBL_PROVIDERS = Arrays.asList(
            "zen.spamhaus.org",
            "bl.spamcop.net",
            "b.barracudacentral.org",
            "dnsbl.sorbs.net"
    );

    @Override
    public void process(Connection connection, EmailParser emailParser, String botAddress) {
        try {
            log.info("Processing email analysis bot for address: {} from session UID: {}",
                    botAddress, connection.getSession().getUID());

            // Determine reply address.
            String replyTo = BotReplyAddressResolver.resolveReplyAddress(connection, botAddress);
            if (replyTo == null || replyTo.isEmpty()) {
                log.warn("Could not determine reply address for bot request from session UID: {}",
                        connection.getSession().getUID());
                return;
            }

            // Generate analysis report.
            String report = generateAnalysisReport(connection);

            // Queue response email.
            queueResponse(connection.getSession(), botAddress, replyTo, report);

            log.info("Successfully queued email analysis bot response to: {} from session UID: {}",
                    replyTo, connection.getSession().getUID());

        } catch (Exception e) {
            log.error("Error processing email analysis bot for address: {} from session UID: {}",
                    botAddress, connection.getSession().getUID(), e);
        }
    }


    /**
     * Generates comprehensive analysis report.
     *
     * @param connection SMTP connection with session data.
     * @return Analysis report as text.
     */
    private String generateAnalysisReport(Connection connection) {
        StringBuilder report = new StringBuilder();
        Session session = connection.getSession();

        report.append("=".repeat(70)).append("\n");
        report.append("EMAIL INFRASTRUCTURE ANALYSIS REPORT\n");
        report.append("Generated by Robin MTA - ").append(LocalDateTime.now()).append("\n");
        report.append("Session UID: ").append(session.getUID()).append("\n");
        report.append("=".repeat(70)).append("\n\n");

        // 1. DNSBL Check.
        appendDnsblCheck(report, session);

        // 2. rDNS Check.
        appendRdnsCheck(report, session);

        // 3. FCrDNS Check.
        appendFcrdnsCheck(report, session);

        // 4. SPF Check (from Rspamd).
        appendSpfCheck(report, session);

        // 5. DKIM Check (from Rspamd and headers).
        appendDkimCheck(report, session);

        // 6. DMARC Check (from Rspamd).
        appendDmarcCheck(report, session);

        // 7. MX Records.
        appendMxCheck(report, session);

        // 8. MTA-STS Check.
        appendMtaStsCheck(report, session);

        // 9. DANE Check.
        appendDaneCheck(report, session);

        // 10. Virus Scan Results.
        appendVirusScanResults(report, session);

        // 11. Spam Analysis.
        appendSpamAnalysis(report, session);

        report.append("\n").append("=".repeat(70)).append("\n");
        report.append("END OF REPORT\n");
        report.append("=".repeat(70)).append("\n");

        return report.toString();
    }

    /**
     * Append DNSBL check results.
     */
    private void appendDnsblCheck(StringBuilder report, Session session) {
        report.append("DNSBL Check\n");
        report.append("-".repeat(70)).append("\n");

        String senderIp = session.getFriendAddr();
        if (senderIp == null || senderIp.isEmpty()) {
            report.append("Sender IP: Not available\n\n");
            return;
        }

        report.append("Sender IP: ").append(senderIp).append("\n");

        // Check RBLs.
        List<RblResult> rblResults = RblChecker.checkIpAgainstRbls(senderIp, DEFAULT_RBL_PROVIDERS, 5);

        boolean isListed = rblResults.stream().anyMatch(RblResult::isListed);

        if (isListed) {
            report.append("Status: BLACKLISTED\n\n");
            report.append("Listed in the following RBLs:\n");
            for (RblResult result : rblResults) {
                if (result.isListed()) {
                    report.append("  - ").append(result.getRblProvider())
                            .append(" (").append(String.join(", ", result.getResponseRecords())).append(")\n");
                }
            }
        } else {
            report.append("Status: NOT BLACKLISTED\n");
            report.append("The sender IP is not listed in any checked RBLs.\n");
        }

        report.append("\n");
    }

    /**
     * Append rDNS check results.
     */
    private void appendRdnsCheck(StringBuilder report, Session session) {
        report.append("Reverse DNS (rDNS)\n");
        report.append("-".repeat(70)).append("\n");

        String senderIp = session.getFriendAddr();
        String rdns = session.getFriendRdns();

        report.append(String.format("%-20s %-50s\n", "IP", "rDNS"));
        report.append(String.format("%-20s %-50s\n",
                senderIp != null ? senderIp : "N/A",
                rdns != null ? rdns : "No rDNS"));
        report.append("\n");
    }

    /**
     * Append FCrDNS (Forward Confirmed Reverse DNS) check results.
     */
    private void appendFcrdnsCheck(StringBuilder report, Session session) {
        report.append("Forward Confirmed Reverse DNS (FCrDNS)\n");
        report.append("-".repeat(70)).append("\n");

        String senderIp = session.getFriendAddr();
        String rdns = session.getFriendRdns();

        if (senderIp == null || rdns == null || rdns.equals("unknown")) {
            report.append("Cannot perform FCrDNS check - missing rDNS\n\n");
            return;
        }

        // Perform forward lookup of rDNS.
        try {
            // Remove trailing dot if present.
            String lookupHost = rdns.endsWith(".") ? rdns.substring(0, rdns.length() - 1) : rdns;
            String forwardIp = Address.getByName(lookupHost).getHostAddress();

            boolean matches = senderIp.equals(forwardIp);

            report.append(String.format("%-20s %-30s %-20s %-10s\n", "IP", "rDNS", "Forward IP", "Result"));
            report.append(String.format("%-20s %-30s %-20s %-10s\n",
                    senderIp, rdns, forwardIp, matches ? "PASS" : "FAIL"));

            if (!matches) {
                report.append("\nWARNING: FCrDNS validation failed! Forward lookup does not match sender IP.\n");
            }
        } catch (Exception e) {
            report.append(String.format("%-20s %-30s %-20s %-10s\n", "IP", "rDNS", "Forward IP", "Result"));
            report.append(String.format("%-20s %-30s %-20s %-10s\n",
                    senderIp, rdns, "Lookup failed", "ERROR"));
            log.debug("FCrDNS lookup failed for {}: {}", rdns, e.getMessage());
        }

        report.append("\n");
    }

    /**
     * Append SPF check results from Rspamd.
     */
    private void appendSpfCheck(StringBuilder report, Session session) {
        report.append("SPF (Sender Policy Framework)\n");
        report.append("-".repeat(70)).append("\n");

        Map<String, Object> spfData = extractRspamdSymbol(session, "R_SPF");

        if (spfData.isEmpty()) {
            report.append("SPF Check: Not performed or no data available\n\n");
            return;
        }

        report.append("SPF Record: ").append(spfData.getOrDefault("description", "N/A")).append("\n");
        report.append("Result: ").append(spfData.getOrDefault("name", "None")).append("\n");
        report.append("Score: ").append(spfData.getOrDefault("score", "0.0")).append("\n");

        report.append("\n");
    }

    /**
     * Append DKIM check results.
     */
    private void appendDkimCheck(StringBuilder report, Session session) {
        report.append("DKIM (DomainKeys Identified Mail)\n");
        report.append("-".repeat(70)).append("\n");

        // Get DKIM results from Rspamd.
        Map<String, Object> dkimData = extractRspamdSymbol(session, "R_DKIM");

        if (dkimData.isEmpty()) {
            report.append("DKIM Check: Not performed or no signature found\n\n");
            return;
        }

        report.append("DKIM Signature: Found\n");
        report.append("Verification: ").append(dkimData.getOrDefault("name", "Unknown")).append("\n");
        report.append("Score: ").append(dkimData.getOrDefault("score", "0.0")).append("\n");
        report.append("Details: ").append(dkimData.getOrDefault("description", "N/A")).append("\n");

        report.append("\n");
    }

    /**
     * Append DMARC check results from Rspamd.
     */
    private void appendDmarcCheck(StringBuilder report, Session session) {
        report.append("DMARC (Domain-based Message Authentication)\n");
        report.append("-".repeat(70)).append("\n");

        Map<String, Object> dmarcData = extractRspamdSymbol(session, "DMARC");

        if (dmarcData.isEmpty()) {
            report.append("DMARC Check: Not performed\n");
            report.append("Error: No DMARC record found or DMARC not checked\n\n");
            return;
        }

        report.append("DMARC Policy: ").append(dmarcData.getOrDefault("description", "N/A")).append("\n");
        report.append("Result: ").append(dmarcData.getOrDefault("name", "None")).append("\n");
        report.append("Score: ").append(dmarcData.getOrDefault("score", "0.0")).append("\n");

        report.append("\n");
    }

    /**
     * Append MX records check.
     */
    private void appendMxCheck(StringBuilder report, Session session) {
        report.append("MX Records\n");
        report.append("-".repeat(70)).append("\n");

        // Extract domain from envelope sender.
        String domain = extractDomain(session);
        if (domain == null) {
            report.append("Cannot determine sender domain\n\n");
            return;
        }

        report.append("Domain: ").append(domain).append("\n\n");

        try {
            MXResolver resolver = new MXResolver();
            List<DnsRecord> mxRecords = resolver.resolveMx(domain);

            if (mxRecords.isEmpty()) {
                report.append("No MX records found\n");
            } else {
                report.append(String.format("%-10s %-50s\n", "Priority", "Server"));
                report.append("-".repeat(70)).append("\n");
                for (DnsRecord mx : mxRecords) {
                    report.append(String.format("%-10d %-50s\n", mx.getPriority(), mx.getValue()));
                }
            }
        } catch (Exception e) {
            report.append("Error retrieving MX records: ").append(e.getMessage()).append("\n");
            log.error("Error retrieving MX records for {}: {}", domain, e.getMessage());
        }

        report.append("\n");
    }

    /**
     * Append MTA-STS check results.
     */
    private void appendMtaStsCheck(StringBuilder report, Session session) {
        report.append("MTA-STS (Mail Transfer Agent Strict Transport Security)\n");
        report.append("-".repeat(70)).append("\n");

        String domain = extractDomain(session);
        if (domain == null) {
            report.append("Cannot determine sender domain\n\n");
            return;
        }

        report.append("Domain: ").append(domain).append("\n");

        try {
            StrictMx strictMx = new StrictMx(domain);
            var policy = strictMx.getPolicy();

            if (policy != null) {
                report.append("MTA-STS Status: ENABLED\n");
                report.append("Policy Mode: ").append(policy.getMode()).append("\n");
                report.append("Max Age: ").append(policy.getMaxAge()).append(" seconds\n");

                List<String> mxMasks = policy.getMxMasks();
                if (!mxMasks.isEmpty()) {
                    report.append("Allowed MX Masks:\n");
                    for (String mask : mxMasks) {
                        report.append("  - ").append(mask).append("\n");
                    }
                }
            } else {
                report.append("MTA-STS Status: NOT ENABLED\n");
                report.append("No MTA-STS policy found for this domain\n");
            }
        } catch (Exception e) {
            report.append("MTA-STS Status: ERROR\n");
            report.append("Error checking MTA-STS: ").append(e.getMessage()).append("\n");
            log.error("Error checking MTA-STS for {}: {}", domain, e.getMessage());
        }

        report.append("\n");
    }

    /**
     * Append DANE check results.
     */
    private void appendDaneCheck(StringBuilder report, Session session) {
        report.append("DANE (DNS-Based Authentication of Named Entities)\n");
        report.append("-".repeat(70)).append("\n");

        String domain = extractDomain(session);
        if (domain == null) {
            report.append("Cannot determine sender domain\n\n");
            return;
        }

        report.append("Domain: ").append(domain).append("\n\n");

        try {
            // Get MX records first.
            XBillDnsRecordClient dnsClient = new XBillDnsRecordClient();
            var mxRecordsOpt = dnsClient.getMxRecords(domain);

            if (mxRecordsOpt.isEmpty() || mxRecordsOpt.get().isEmpty()) {
                report.append("No MX records found - cannot check DANE\n");
            } else {
                List<String> mxHosts = mxRecordsOpt.get().stream()
                        .map(DnsRecord::getValue)
                        .toList();

                boolean anyDaneFound = false;
                for (String mxHost : mxHosts) {
                    List<DaneRecord> daneRecords = DaneChecker.checkDane(mxHost);

                    if (!daneRecords.isEmpty()) {
                        anyDaneFound = true;
                        report.append("MX Host: ").append(mxHost).append("\n");
                        report.append("DANE Status: ENABLED\n");
                        report.append("TLSA Records:\n");

                        for (DaneRecord dane : daneRecords) {
                            report.append("  - Usage: ").append(dane.getUsage())
                                    .append(" (").append(dane.getUsageDescription()).append(")\n");
                            report.append("    Selector: ").append(dane.getSelector())
                                    .append(" (").append(dane.getSelectorDescription()).append(")\n");
                            report.append("    Matching: ").append(dane.getMatchingType())
                                    .append(" (").append(dane.getMatchingTypeDescription()).append(")\n");
                            report.append("    Data: ").append(dane.getCertificateData().substring(0,
                                    Math.min(64, dane.getCertificateData().length()))).append("...\n");
                        }
                        report.append("\n");
                    }
                }

                if (!anyDaneFound) {
                    report.append("DANE Status: NOT ENABLED\n");
                    report.append("No TLSA records found for any MX hosts\n");
                }
            }
        } catch (Exception e) {
            report.append("DANE Check: ERROR\n");
            report.append("Error: ").append(e.getMessage()).append("\n");
            log.error("Error checking DANE for {}: {}", domain, e.getMessage());
        }

        report.append("\n");
    }

    /**
     * Append virus scan results from ClamAV.
     */
    private void appendVirusScanResults(StringBuilder report, Session session) {
        report.append("Virus Scan Results (ClamAV)\n");
        report.append("-".repeat(70)).append("\n");

        if (!session.getEnvelopes().isEmpty()) {
            MessageEnvelope envelope = session.getEnvelopes().getLast();
            List<Map<String, Object>> scanResults = envelope.getScanResults();

            boolean clamavFound = false;
            for (Map<String, Object> result : scanResults) {
                if ("clamav".equals(result.get("scanner"))) {
                    clamavFound = true;
                    Boolean infected = (Boolean) result.get("infected");

                    if (Boolean.TRUE.equals(infected)) {
                        report.append("Status: INFECTED\n");
                        Object viruses = result.get("viruses");
                        if (viruses != null) {
                            report.append("Viruses Found:\n");
                            report.append("  ").append(viruses.toString()).append("\n");
                        }
                    } else {
                        report.append("Status: CLEAN\n");
                        report.append("No viruses detected\n");
                    }
                }
            }

            if (!clamavFound) {
                report.append("Status: NOT SCANNED\n");
                report.append("ClamAV scan was not performed\n");
            }
        } else {
            report.append("No scan results available\n");
        }

        report.append("\n");
    }

    /**
     * Append spam analysis results from Rspamd.
     */
    private void appendSpamAnalysis(StringBuilder report, Session session) {
        report.append("Spam Analysis (Rspamd)\n");
        report.append("-".repeat(70)).append("\n");

        if (!session.getEnvelopes().isEmpty()) {
            MessageEnvelope envelope = session.getEnvelopes().getLast();
            List<Map<String, Object>> scanResults = envelope.getScanResults();

            boolean rspamdFound = false;
            for (Map<String, Object> result : scanResults) {
                if ("rspamd".equals(result.get("scanner"))) {
                    rspamdFound = true;
                    Double score = (Double) result.get("score");
                    Boolean spam = (Boolean) result.get("spam");

                    report.append("Spam Score: ").append(score != null ? score : "0.0").append("\n");
                    report.append("Spam Status: ").append(Boolean.TRUE.equals(spam) ? "SPAM" : "NOT SPAM").append("\n\n");

                    Object symbols = result.get("symbols");
                    if (symbols instanceof Map) {
                        @SuppressWarnings("unchecked")
                        Map<String, Object> symbolMap = (Map<String, Object>) symbols;
                        if (!symbolMap.isEmpty()) {
                            report.append("Triggered Rules:\n");
                            report.append(String.format("%-8s %-40s\n", "Score", "Rule Name"));
                            report.append("-".repeat(70)).append("\n");

                            symbolMap.forEach((key, value) -> {
                                double symbolScore = value instanceof Number ? ((Number) value).doubleValue() : 0.0;
                                report.append(String.format("%-8.2f %-40s\n", symbolScore, key));
                            });
                        }
                    }
                }
            }

            if (!rspamdFound) {
                report.append("Status: NOT ANALYZED\n");
                report.append("Rspamd analysis was not performed\n");
            }
        } else {
            report.append("No analysis results available\n");
        }

        report.append("\n");
    }

    /**
     * Extract a specific symbol from Rspamd results.
     */
    @SuppressWarnings("unchecked")
    private Map<String, Object> extractRspamdSymbol(Session session, String symbolPrefix) {
        if (!session.getEnvelopes().isEmpty()) {
            MessageEnvelope envelope = session.getEnvelopes().getLast();
            List<Map<String, Object>> scanResults = envelope.getScanResults();

            for (Map<String, Object> result : scanResults) {
                if ("rspamd".equals(result.get("scanner"))) {
                    Object symbols = result.get("symbols");
                    if (symbols instanceof Map) {
                        Map<String, Object> symbolMap = (Map<String, Object>) symbols;
                        for (Map.Entry<String, Object> entry : symbolMap.entrySet()) {
                            if (entry.getKey().startsWith(symbolPrefix)) {
                                Map<String, Object> data = new HashMap<>();
                                data.put("name", entry.getKey());
                                data.put("score", entry.getValue());
                                data.put("description", entry.getKey());
                                return data;
                            }
                        }
                    }
                }
            }
        }
        return Collections.emptyMap();
    }

    /**
     * Extract domain from envelope sender.
     */
    private String extractDomain(Session session) {
        if (!session.getEnvelopes().isEmpty()) {
            String mailFrom = session.getEnvelopes().getLast().getMail();
            if (mailFrom != null && mailFrom.contains("@")) {
                return mailFrom.substring(mailFrom.indexOf("@") + 1);
            }
        }
        return null;
    }

    /**
     * Queues the response email for delivery.
     */
    private void queueResponse(Session session, String botAddress, String replyTo, String report) {
        try {
            // Create MIME part for the report.
            List<MimePart> parts = new ArrayList<>();
            parts.add(new TextMimePart(report.getBytes(StandardCharsets.UTF_8))
                    .addHeader("Content-Type", "text/plain; charset=\"UTF-8\"")
                    .addHeader("Content-Transfer-Encoding", "8bit")
            );

            // Use BotHelper to queue the response.
            BotHelper.queueBotResponse(
                    session,
                    botAddress,
                    replyTo,
                    "Robin Email Analysis BOT - " + session.getUID(),
                    parts
            );

            log.info("Queued email analysis bot response for delivery to: {}", replyTo);

        } catch (IOException e) {
            log.error("Failed to queue email analysis bot response: {}", e.getMessage(), e);
        }
    }

    @Override
    public String getName() {
        return "email";
    }
}
